# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
"""Generated protocol buffer code."""
import grpc
# from typing import TypeVar, Generic
import json
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database
# from pyparsing import null_debug_action
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()

DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x0einternal.proto\"\x1a\n\nInputProto\x12\x0c\n\x04utf8\x18\x02 \x01(\t\"K\n\x0bOutputProto\x12\t\n\x01\x63\x18\x01 \x01(\x05\x12\x0b\n\x01m\x18\x02 \x01(\tH\x00\x12\x0e\n\x04utf8\x18\x03 \x01(\tH\x00\x12\x0c\n\x02\x62s\x18\x04 \x01(\x0cH\x00\x42\x06\n\x04\x64\x61ta2)\n\x04Grpc\x12!\n\x04\x63\x61ll\x12\x0b.InputProto\x1a\x0c.OutputProtob\x06proto3')


_INPUTPROTO = DESCRIPTOR.message_types_by_name['InputProto']
_OUTPUTPROTO = DESCRIPTOR.message_types_by_name['OutputProto']
InputProto = _reflection.GeneratedProtocolMessageType('InputProto', (_message.Message,), {
    'DESCRIPTOR': _INPUTPROTO,
    '__module__': 'krpc'
    # @@protoc_insertion_point(class_scope:InputProto)
})
_sym_db.RegisterMessage(InputProto)

OutputProto = _reflection.GeneratedProtocolMessageType('OutputProto', (_message.Message,), {
    'DESCRIPTOR': _OUTPUTPROTO,
    '__module__': 'krpc'
    # @@protoc_insertion_point(class_scope:OutputProto)
})
_sym_db.RegisterMessage(OutputProto)

_GRPC = DESCRIPTOR.services_by_name['Grpc']
if _descriptor._USE_C_DESCRIPTORS == False:

    DESCRIPTOR._options = None
    _INPUTPROTO._serialized_start = 18
    _INPUTPROTO._serialized_end = 44
    _OUTPUTPROTO._serialized_start = 46
    _OUTPUTPROTO._serialized_end = 121
    _GRPC._serialized_start = 123
    _GRPC._serialized_end = 164
# @@protoc_insertion_point(module_scope)


# mycls

# T = TypeVar('T')
# class RpcResult(Generic[T]):

class RpcResult():
    OK: int = 0

    """
    Args:
      data: json.loads
    """
    def __init__(self, code: int, message: str = None, data=None,rpcError:bool = False):
        self.code = code
        self.message = message
        self.data = data
        self.rpcError = rpcError

    def isOk(self) -> bool:
        return self.code == RpcResult.OK

    def toJson(self) -> str:
        return json.dumps(self, default=lambda o: o.__dict__, ensure_ascii = False)

# @staticmethod
def _rpcCall(callable: grpc.UnaryUnaryMultiCallable, reqJson,
            metadata: tuple = None, timeout: int = None) -> RpcResult:
    try:
        outproto = callable(InputProto(utf8=json.dumps(reqJson)),
                            metadata=metadata, timeout=timeout)
        res = RpcResult(outproto.c)
        data = outproto.utf8
        if(res.isOk()):
            res.data = json.loads(data)
        else:
            res.message = outproto.m
        return res
    except grpc.RpcError as err:
        return RpcResult(err.code().value[0]
            ,message=err.code().name +" : "+ err.details()
            ,rpcError=True)

    
def rpcCall(channel: grpc.Channel,
            fullMethod: str, reqJson,
            metadata: tuple = None, timeout: int = None) -> RpcResult:
    callable= channel.unary_unary(fullMethod,
                      request_serializer=InputProto.SerializeToString,
                      response_deserializer=OutputProto.FromString,)
    return _rpcCall(callable,reqJson,metadata,timeout)

"""
open a grpc.Channel.
need to close it after use or 
```
    with xxx as channel:
        do some thing
``` 
Args:

"""
def openChannel(domain:str,port:int=None,ssl:bool=True,options:list=None,compression:list=None) -> grpc.Channel:
    # import os
    # os.environ["GRPC_DNS_RESOLVER"] = "native"
    if port is not None:
        domain+=':'+str(port)
    if ssl:
        return grpc.secure_channel(target=domain,
                            credentials=grpc.ssl_channel_credentials(),
                               options=options,compression=compression)
    else:
        return grpc.insecure_channel(target=domain,options=options,compression=compression)

class ServiceStub(object):
    
    def __init__(self, channel: grpc.Channel, app: str, service: str,
                 accessToken: str = None,
                 clientId: str = None,
                 clientMeta: dict = None):
        """Constructor.
        Args:
            channel: A grpc.Channel.
            app: 应用名
            service: 服务名
        """
        self.channel = channel
        self.prefix = '/'+app+'/'+service+'/'
        headers = []
        if(accessToken is not None):
            headers.append(('authorization', 'Bearer '+accessToken))
        if(clientId is not None):
            headers.append(('c-id', clientId))
        if(clientMeta is not None):
            headers.append(('c-meta', json.dumps(clientMeta)))
        self._headers = tuple(headers)
        self._calls:dict[str,grpc.UnaryUnaryMultiCallable]={}

    """
    Args:
      req:  Object, will be tranfer to json
      metadata : list[tuple[str,str]]
    """
    def call(self, method: str, req, metadata: list = None, timeout: int = None) -> RpcResult:
        if metadata is None:
            metadata = self._headers
        else:
            metadata.extend(self._headers)
        callable = self._calls.get(method)
        if callable is None:
            callable =  self.channel.unary_unary(self.prefix+method,
                      request_serializer=InputProto.SerializeToString,
                      response_deserializer=OutputProto.FromString,) 
            self._calls[method] = callable  
        return _rpcCall(callable, req, metadata=metadata, timeout=timeout)

